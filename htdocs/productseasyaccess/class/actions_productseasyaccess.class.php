<?php
/* Copyright (C) 2012-2015   Stephen Larroque <lrq3000@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * at your option any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *      \file       htdocs/productseasyaccess/class/actions_productseasyaccess.class.php
 *      \ingroup    customfields
 *      \brief      Hook file for ProductsEasyAccess to manage ODT templating (render accessible all the products standard and custom fields)
 *		\author		Stephen Larroque
 */

/**
 *      \class      actions_productseasyaccess
 *      \brief      Hook file for ProductsEasyAccess to manage ODT templating (render accessible all the products standard and custom fields)
 */
class ActionsProductsEasyAccess // extends CommonObject
{

    function ODTSubstitutionLine(&$parameters, $object, $action) {
        global $conf, $db, $dolibarr_main_url_root;
        static $line_counter = 0;

        //$lparameters = (array)$parameters; // convert the $parameters because sometimes an object is returned instead of an array

        require(dirname(__FILE__).'/../conf/conf_pea.lib.php');

        // Init parameters
        $line = $parameters['line'];
        $odfHandler = &$parameters['odfHandler'];
        $object = $parameters['object'];
        $substitutionarray = &$parameters['substitutionarray'];

        // Init caching
        static $productslinescache; // cache for the lines' customfields (their data won't change between two successive calls of this function)
        static $sqlwrapper; // cache the SQL Wrapper object
        static $collist; // cache the list of columns, so that for next lines where there's no link to a predefined product, we can just replace the product's tags by empty strings

        if (!isset($productslinescache)) $productslinescache = new stdClass(); // initialize the cache object (avoid php >= 5.3 warnings)

        if (empty($object) or empty($line)) return; // check that this function is called with an $object and $line for substitution in ODTs (else it may be called in the email config page and create a bug)

        // Process only if the module is enabled (because this substitution function may be called even if the module is disabled)
        if ($conf->global->MAIN_MODULE_PRODUCTSEASYACCESS) {

            // Get the lines segment
            // NOTE: setSegment returns a segment if it already exists (it won't create it)
            // NOTE2: the segment will NOT contain only one segment, but incrementally all segments (try to print $listlines->getXmlParsed() to convince yourself, you will see that at each iteration of the loop, it will contain all previously generated data, all but the current iteration because it's not already generated using $listlines->merge() !)
            // NOTE3: $listlines->merge() will append the current segment to the list, so everytime you call merge() it will append the same segment (with your latest modifications like setVars() or setImage()). $odfHandler->mergeSegment('lines') will output and seal all that was generated by the segment.
            // NOTE4: so in fact, at every iteration, we do NOT get a single segment, but rather we append a new segment over the previously generated segment(s), but it still counts as only a single segment all along!
            $listlines = $odfHandler->setSegment('lines');

            // == FETCHING FIELDS
            // If there's no cache yet, we fetch ALL the products' fields (we get every fields' values for every products linked to this $object)
            if (empty($productslinescache->{$object->table_element})) {
                include_once(dirname(__FILE__).'/../lib/productseasyaccess.lib.php');
                fill_object_with_products_fields($object, null, $langs, true); // fetch the fields for all products (standard and custom fields)
                $productslinescache->{$object->table_element} = $object->productslines; // save the result into a cache (different for each module, will avoid conflicts if there are multiple generating functions called at once)
            // Else if the cache exists, we use it directly (this dramatically lowers the processing time because we query the database only once for ALL products and fields at once, so next time this function is called for the next line, we already have everything ready and it will be blazingly fast)
            } else {
                $object->productslines = $productslinescache->{$object->table_element}; // load the cache
            }

            // == SUBSTITUTION
            // If this product line is linked to a predefined product, then we can substitute with the product's fields (standard and custom fields)
            if (!empty($line->fk_product) and !empty($object->productslines->{$line->fk_product})) {
                // -- Begin to populate the substitution array with product's data
                $substitutionarray['line_counter'] = ++$line_counter; // Allow to enumerate the product number
                foreach ($object->productslines->{$line->fk_product} as $key=>$value) { // One field at a time, relative to the current line being processed
                    // If this is not a photo, we do the standard procedure
                    if (!(strpos($key, 'photo') === 0)) { // Note that there can be multiple photos for one same product, that's why we do it in the foreach loop
                        // Add this customfield's data to the substitution array (will automatically be replaced inside the ODT, eg: {line_weight} becomes '0.2314')
                        $substitutionarray['line_'.$key] = $value; // adding this value to an odt variable (format: {line_myfield} for standard fields or {line_cf_myfield} if it is a custom field)
                    // Else if it is a photo, it oughts to be treated differently
                    } else {
                        // TRICK: we DON'T put the variable into the substitution array, but rather we put it into another key, because we want the key of the photo to NOT be substituted but replaced by an image.
                        $substitutionarray['line_'.$key.'_path'] = $value; // thus we store the variable into another key (eg: {line_photo1_path}), which will be used later to detect if this photo is defined or not (so that we can delete photo tags which are empties)
                        // Exception handling (see below for the explanation)
                        try {
                            // We set an image. It will be included inside the ODT via PclZip (PclZipProxy).
                            $listlines->setImage('line_'.$key, $value); // Note: the image will be linked to the variable {line_photox} which means that you need to NOT substitute this variable, else the substitution will take over the image and the image won't be included in the document!
                        } catch(Exception $e) {
                            // TODO: setImage will fail if the tag is not found in the document. We should enhance odf.php to be resilient against this kind of failure (just like it already is with substitution), but meanwhile this workaround works.
                        }
                    }
                }

                // Manage barcode if enabled
                // We do it after the foreach loop since there can be only one barcode per product
                if ($peaBarcode and !empty($object->productslines->{$line->fk_product}->barcode) and
                !empty($object->productslines->{$line->fk_product}->barcode_type_code) and !empty($object->productslines->{$line->fk_product}->barcode_type_coder) ) { // Check that the option is enabled and that the product has a barcode
                    try {
                        // Check that we can write in documents folder, this is where we will store the generated barcodes (since barcodes aren't stored by default by Dolibarr, they are only dynamically generated and show on-the-fly)
                        if (@is_writeable(DOL_DATA_ROOT)) {
                            // Directory where pea barcodes are stored
                            //$barcodedir = DOL_DATA_ROOT.'/pea/barcodes/'; // where PEA generated barcodes will be stored for inclusion in the ODT document (they are copied and zipped into the ODT document when it is generated, but before generation we need to have a local image, else ODTphp can't copy it from the web!)
                            $barcodedir = $conf->barcode->dir_temp;
                            if (!file_exists($barcodedir) and !is_dir($barcodedir)) dol_mkdir($barcodedir); // If the barcode folder does not exists, we create it

                            // Vars, just for ease of coding
                            $code = $object->productslines->{$line->fk_product}->barcode; // eg: 123456789123
                            $generator = $object->productslines->{$line->fk_product}->barcode_type_coder; // eg: phpbarcode
                            $encoding = $object->productslines->{$line->fk_product}->barcode_type_code; // eg: EAN13 (or another number, I can't remember ;) )

                            // Barcode image fullpath
                            //$barcodepath = $barcodedir.$generator.$encoding.$code.'.png'; // This should ensure that it's a unique identifier
                            $barcodepath = $conf->barcode->dir_temp.'/barcode_'.$code.'_'.$encoding.'.png';

                            // We use here the same tricks as for the photo: we will use the path to check whether the barcode is defined or not
                            $substitutionarray['line_barcode_image_path'] = $barcodepath;
                            $substitutionarray['line_barcode_image_url'] = $dolibarr_main_url_root.'/viewimage.php?modulepart=barcode&generator='.urlencode($object->productslines->{$line->fk_product}->barcode_type_coder).'&code='.urlencode($object->productslines->{$line->fk_product}->barcode).'&encoding='.urlencode($object->productslines->{$line->fk_product}->barcode_type_code);

                            // CACHE: Generate the barcode image only if it does not already exists. Thus we will reuse the barcode image if it has already been generated, making some sort of cache (since generating an image in PHP can be quite ressource consuming)
                            if (!file_exists($barcodepath)) {

                                // Fetch the list of barcode generator modules available (to include them)
                                $dirbarcode=array_merge(array("/core/modules/barcode/"),$conf->modules_parts['barcode']);
                                $result=0;
                                foreach($dirbarcode as $reldir)
                                {
                                    $dir=dol_buildpath($reldir,0);
                                    $newdir=dol_osencode($dir);

                                    // Check if directory exists (we do not use dol_is_dir to avoid loading files.lib.php)
                                    if (! is_dir($newdir)) continue;

                                    $result=@include_once $newdir.$generator.'.modules.php';
                                    if ($result) break;
                                }

                                // Load barcode class
                                $classname = "mod".ucfirst($generator);
                                $module = new $classname($db);

                                // Setup needed barcode global variables
                                // These variables are defined exactly with the same values inside the included files (barcode.lib.php), but these definitions are out-of-scope here, the file needs to be rewritten in a class with attributes instead of global variables to avoid this problem.
                                // Meanwhile, the workaround here is that we have just copied from barcode.lib.php the definitions of the required variables to generate the barcode.
                                global $font_loc, $filebarcode, $bar_color, $bg_color, $text_color;

                                if (empty($font_loc)) {
                                    if (defined('DOL_DEFAULT_TTF_BOLD')) $font_loc=constant('DOL_DEFAULT_TTF_BOLD');
                                    // Automatic-Detection of Font if running Windows
                                    // DOL_CHANGE LDR
                                    if (isset($_SERVER['WINDIR']) && @file_exists($_SERVER['WINDIR'])) $font_loc=$_SERVER['WINDIR'].'\Fonts\arialbd.ttf';
                                    if (empty($font_loc)) die('DOL_DEFAULT_TTF_BOLD must de defined with full path to a TTF font.');
                                }

                                $bar_color=Array(0,0,0);
                                $bg_color=Array(255,255,255);
                                $text_color=Array(0,0,0);

                                // TRICKS: by default, the Dolibarr barcode modules do not allow to save the barcode into a file (there are functions drafts defined but they aren't finished).
                                // However, barcode.lib.php allows to use a global variable $filebarcode to specify a filepath where to save the image. Thus, we overwrite this global variable (by default always empty) and we get the barcode saved into the specified filepath.
                                $tmp1 = $filebarcode; // exchange var with a temporary register so that we can restore the original value later
                                $filebarcode = $barcodepath;

                                // At last! Call the barcode generator
                                if ($module->encodingIsSupported($encoding))
                                {
                                    $result=$module->writeBarCode($code,$encoding,$readable);
                                }
                                $filebarcode = $tmp1; // set back the $filebarcode global var

                            }

                            // Include image into the ODT file. It will be included inside the ODT via PclZip (PclZipProxy) and replace the {line_barcode_image} tag by the image.
                            $listlines->setImage('line_barcode_image', $barcodepath);

                            /* ALTERNATIVE WAY TO GENERATE AND SAVE BARCODES IT if the current way ever stops working.
                            // Redirect output in a variable (since Dolibarr automatically print barcode image on STDOUT but does not allow to write in an image file), and then post-process the output to only keep the barcode image (stripping HTTP headers and errors), which we will write in a image file.
                            // DONE: output redirection and output writing in a imagefile on disk. TODO: post-processing to reliably strip HTTP headers and errors.
                            ob_start();
                            $bar = barcode_print($object->productslines->{$line->fk_product}->barcode, $encoding, 1, "png");
                            $bar = ob_get_contents();
                            ob_end_clean();
                            print($bar);
                            file_put_contents($barcodepath, $bar);
                            */
                            // For reference: useful files for barcode generation:
                            // viewimage.php: search for the following: $result=$module->buildBarCode($code,$encoding,$readable);
                            // barcode.lib.php
                            // phpbarcode.modules.php
                            // Problème: variables globales pas définies, surtout je pense: global $genbarcode_loc, $bar_color, $bg_color, $text_color, $font_loc
                            // Donc ça enregistre une image en overwritant $filebarcode, mais une image noire...
                            //barcode_print($object->productslines->{$line->fk_product}->barcode, $encoding, 1, "png");
                        }
                    } catch(Exception $e) {
                        //print($e);
                        // TODO: setImage will fail if the tag is not found in the document. We should enhance odf.php to be resilient against this kind of failure (just like it already is with substitution), but meanwhile this workaround works.
                    }
                }

            // Else if this product is NOT a predefined product (a free product line), then there's no product's fields to fetch, BUT we still must erase the tags to avoid leaving non transformed tags in the rendered ODT document
            } else {
                // If there's no cache yet, we load all the columns (fields) from the database
                if (empty($collist)) {
                    // Init the final list of products' fields
                    $collist = array();
                    // Init SQL wrapper if not defined
                    if (!isset($sqlwrappe)) {
                        include_once(dirname(__FILE__).'/sqlwrapper.class.php');
                        $sqlwrapper = new SQLWrapper($db);
                    }
                    // Fetching products' standard fields list
                    $collist1 = $sqlwrapper->fetchAny('column_name', 'information_schema.columns',"table_schema = '".$db->database_name."'AND table_name = '".MAIN_DB_PREFIX.'product'."'");
                    foreach ($collist1 as $col) { // Store the columns in the final list
                        $collist[] = $col->column_name;
                    }
                    // Fetching products' custom fields list
                    if ($conf->global->MAIN_MODULE_CUSTOMFIELDS) {
                        // Loading the CustomFields config (needed to load the custom fields prefix)
                        // DEPRECATED: DOL_DOCUMENT_ROOT_ALT does not exist anymore since Dolibarr v3.5: http://nongnu.13855.n7.nabble.com/DOL-URL-ROOT-ALT-removed-td175588.html
                        include(dol_buildpath('/customfields/conf/conf_customfields.lib.php')); // we need to do a manual include because there's no dol_include(), if it fails with the normal root, we try the alternative root
                        $collist2 = $sqlwrapper->fetchAny('column_name', 'information_schema.columns',"table_schema = '".$db->database_name."'AND table_name = '".MAIN_DB_PREFIX.'product_customfields'."'");
                        foreach ($collist2 as $col) { // Store the columns in the final list
                            $collist[] = $fieldsprefix.$col->column_name;
                        }
                    }
                }

                // Clean up ODT PEA tags by substituting them by an empty string (since they are not linked to a predefined product, else if we don't do that it will leave the ODT tags as is or even worse: it can substitute with the value of a previous product)
                foreach ($collist as $col) {
                    $substitutionarray['line_'.$col] = '';
                }
            }

            // Finally, clean up any photo tag that was not converted into an image (we do this because photos aren't stored inside the database, so we must specify these 'artificial' fields manually)
            for($i=1;$i<=10;$i++) {
                // We detect if the {line_photo$i_path} variable exists, if true then the photo exists, else it's empty and we want to delete these empty tags
                if (empty($substitutionarray['line_photo'.$i.'_path'])) {
                    $substitutionarray['line_photo'.$i] = ''; // replace the tag by nothing
                    $substitutionarray['line_photo'.$i.'_thumbnail'] = '';
                    $substitutionarray['line_photo'.$i.$peaThumbExtName] = '';
                }
            }

            // Also clean up barcode, else barcodes of previous products in the list will be wrongly reused!
            if (empty($substitutionarray['line_barcode_image_path'])) {
                $substitutionarray['line_barcode_image'] = '';
                $substitutionarray['line_barcode'] = '';
            }

            /*
            print('<pre>');
            print_r($substitutionarray);
            print('</pre><br>');
            */
            
        }
    }

}
